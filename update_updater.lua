local script_author = 'Alex_Swift'local script_version = '2.1.4'require "lib.moonloader"local json = require "dkjson"local lfs = require("lfs")local encoding = require 'encoding'encoding.default = 'CP1251'local u8 = encoding.UTF8-- Константыlocal GITHUB_USER = "egoist1313"local GITHUB_REPO = "DunaevskiyLua"local GITHUB_BRANCH = "test"local SAVE_PATH = getGameDirectory() .. "\\moonloader\\"local scripts_dir_rel = "LuaDunaevskiy"local LOCAL_JSON = SAVE_PATH .. "LuaDunaevskiy\\versions.json"local TEMP_JSON = SAVE_PATH .. "LuaDunaevskiy\\temp_config.json"local UPDATER_NAME = "updater.luac"local UPDATER_NAME_NO_EXT = "updater"local UPDATER_PATH = SAVE_PATH .. "LuaDunaevskiy\\" .. UPDATER_NAMElocal THIS_SCRIPT_NAME = "update_updater.lua"local THIS_SCRIPT_PATH = SAVE_PATH .. "LuaDunaevskiy\\" .. THIS_SCRIPT_NAMElocal MAX_WAIT_TIME = 300000 -- 5 минут в миллисекундах-- Логированиеlocal log_buffer = {}function logToFile(message, level)    level = level or "INFO"    local log_path = SAVE_PATH .. "LuaDunaevskiy\\"    ensureDirectoryExists(log_path)    table.insert(log_buffer, os.date("[%Y-%m-%d %H:%M:%S] ") .. "[" .. level .. "] " .. message)    if #log_buffer >= 10 then        local file = io.open(log_path .. "update_updater.log", "a")        if file then            for _, msg in ipairs(log_buffer) do                file:write(msg .. "\n")            end            file:close()            log_buffer = {}        end    endendfunction flushLogBuffer()    if #log_buffer > 0 then        local log_path = SAVE_PATH .. "LuaDunaevskiy\\"        local file = io.open(log_path .. "update_updater.log", "a")        if file then            for _, msg in ipairs(log_buffer) do                file:write(msg .. "\n")            end            file:close()            log_buffer = {}        end    endendfunction ensureDirectoryExists(path)    local success, err = pcall(function()        os.execute('mkdir "' .. path .. '" 2>nul')    end)    if not success then        logToFile("Ошибка создания папки: " .. path .. ": " .. tostring(err), "ERROR")        sampAddChatMessage("[UpdateUpdater] Не удалось создать папку: " .. path, 0xFF0000)    endend-- Функция загрузки JSONfunction loadJson(file_path, default_data)    if not file_path then        logToFile("Ошибка: file_path is nil in loadJson", "ERROR")        return default_data    end    local file = io.open(file_path, "rb")    if file then        local content = file:read("a"):gsub("^\239\187\191", "")        file:close()        local success, result = pcall(json.decode, content)        if success and result then            logToFile("Успешно загружен JSON: " .. file_path .. ", содержимое: " .. json.encode(result, { indent = true }), "INFO")            return result        else            logToFile("Ошибка декодирования JSON: " .. file_path .. ": " .. tostring(result), "ERROR")            return default_data        end    else        logToFile("Файл JSON не найден: " .. file_path .. ", используется значение по умолчанию", "INFO")        return default_data    endend-- Функция сохранения JSONfunction saveJson(file_path, data)    if not file_path then        logToFile("Ошибка: file_path is nil in saveJson", "ERROR")        return    end    local dir_path = file_path:match("^(.*\\)[^\\]+$")    if dir_path then        ensureDirectoryExists(dir_path)    end    local file = io.open(file_path, "w")    if file then        local success, err = pcall(function()            file:write(json.encode(data, { indent = true }))        end)        file:close()        if success then            logToFile("Успешно сохранён JSON: " .. file_path, "INFO")        else            logToFile("Ошибка кодирования JSON: " .. file_path .. ": " .. tostring(err), "ERROR")        end    else        logToFile("Ошибка открытия файла для сохранения JSON: " .. file_path, "ERROR")    endend-- Функция сравнения версийfunction isNewerVersion(local_ver, remote_ver)    if not local_ver then return true end    local l_parts = { local_ver:match("(%d+)%.(%d+)%.(%d+)") }    local r_parts = { remote_ver:match("(%d+)%.(%d+)%.(%d+)") }    if not l_parts[1] or not r_parts[1] then return local_ver ~= remote_ver end    for i = 1, 3 do        local l_num, r_num = tonumber(l_parts[i]) or 0, tonumber(r_parts[i]) or 0        if l_num < r_num then return true end        if l_num > r_num then return false end    end    return falseend-- Функция загрузки файлаfunction downloadFile(url, save_path, name, callback)    logToFile("Попытка загрузки файла: " .. save_path .. " (имя: " .. name .. "), URL: " .. url, "INFO")    local download_complete = false    downloadUrlToFile(url, save_path, function(id, status, p1, p2)        if status == require('moonloader').download_status.STATUSEX_ENDDOWNLOAD then            -- Проверка существования файла            if doesFileExist(save_path) then                logToFile("Файл " .. name .. " успешно загружен и существует по пути: " .. save_path, "INFO")                callback(true)            else                logToFile("Файл " .. name .. " не найден после загрузки по пути: " .. save_path, "ERROR")                callback(false, "Файл не найден после загрузки")            end            download_complete = true        elseif status == require('moonloader').download_status.STATUSEX_ERROR then            logToFile("Ошибка загрузки файла " .. name .. ": " .. tostring(p1), "ERROR")            callback(false, tostring(p1))            download_complete = true        end    end)    local timeout = 90000    local start_time = os.clock()    while not download_complete and (os.clock() - start_time) * 1000 < timeout do        wait(100)    end    if not download_complete then        logToFile("Таймаут загрузки: " .. save_path .. " (имя: " .. name .. ")", "ERROR")        callback(false, "Таймаут загрузки")    endend-- Функция выгрузки скриптаfunction unloadUpdater()    local max_attempts = 3    local attempt = 1    local updater_handle = script.find(UPDATER_NAME) or script.find(UPDATER_NAME_NO_EXT)        logToFile("Поиск скрипта updater.luac: " .. tostring(updater_handle ~= nil), "INFO")        while updater_handle and attempt <= max_attempts do        logToFile("Попытка выгрузки updater.luac #" .. attempt, "INFO")        local success, result = pcall(updater_handle.unload, updater_handle)        if success then            -- Проверяем, действительно ли скрипт выгружен            wait(1000) -- Увеличенная задержка для завершения выгрузки            updater_handle = script.find(UPDATER_NAME) or script.find(UPDATER_NAME_NO_EXT)            if not updater_handle then                logToFile("Скрипт updater.luac успешно выгружен", "INFO")                sampAddChatMessage("[UpdateUpdater] Скрипт updater.luac выгружен", 0x00FF00)                return true            else                logToFile("Скрипт updater.luac всё ещё активен после попытки выгрузки", "WARN")            end        else            logToFile("Ошибка выгрузки updater.luac: " .. tostring(result), "ERROR")        end        attempt = attempt + 1        wait(1000)    end        logToFile("Не удалось выгрузить updater.luac после " .. max_attempts .. " попыток", "ERROR")    sampAddChatMessage("[UpdateUpdater] Не удалось выгрузить updater.luac", 0xFF0000)    return falseend-- Основная функцияfunction main()    if not isSampLoaded() or not isSampfuncsLoaded() then        logToFile("SA:MP или sampfuncs не загружены", "ERROR")        sampAddChatMessage("[UpdateUpdater] SA:MP или sampfuncs не загружены", 0xFF0000)        return    end    -- Ожидание готовности SA:MP    while not isSampAvailable() do wait(100) end    -- Логирование путей для отладки    logToFile("SAVE_PATH: " .. SAVE_PATH, "INFO")    logToFile("LOCAL_JSON: " .. LOCAL_JSON, "INFO")    logToFile("UPDATER_PATH: " .. UPDATER_PATH, "INFO")    -- Загрузка локального versions.json    local local_versions = loadJson(LOCAL_JSON, { versions = {}, is_updated = false })    local start_time = os.clock()    -- Ожидание is_updated == true    while not local_versions.is_updated and (os.clock() - start_time) * 1000 < MAX_WAIT_TIME do        logToFile("Ожидание is_updated == true, текущее значение: " .. tostring(local_versions.is_updated), "INFO")        wait(2000) -- Увеличенная задержка        local_versions = loadJson(LOCAL_JSON, { versions = {}, is_updated = false })    end    if not local_versions.is_updated then        logToFile("Таймаут ожидания is_updated == true", "ERROR")        sampAddChatMessage("[UpdateUpdater] Таймаут ожидания завершения обновлений", 0xFF0000)        -- Самоудаление при таймауте        wait(1000)        local success, err = pcall(os.remove, THIS_SCRIPT_PATH)        if success then            logToFile("Скрипт update_updater.lua удалён (таймаут)", "INFO")        else            logToFile("Ошибка удаления update_updater.lua: " .. tostring(err), "ERROR")            sampAddChatMessage("[UpdateUpdater] Ошибка удаления update_updater.lua", 0xFF0000)        end        flushLogBuffer()        return    end    -- Загрузка update_config.json    local remote_version, remote_path    local success = false    local max_attempts = 3    local attempt = 1    while attempt <= max_attempts and not success do        logToFile("Попытка загрузки update_config.json #" .. attempt, "INFO")        downloadFile(            string.format("https://raw.githubusercontent.com/%s/%s/%s/update_config.json", GITHUB_USER, GITHUB_REPO, GITHUB_BRANCH),            TEMP_JSON,            "update_config.json",            function(result, err)                if result then                    local file = io.open(TEMP_JSON, "rb")                    if file then                        local content = file:read("a"):gsub("^\239\187\191", ""):gsub("[\r\n]+$", "")                        file:close()                        local config, _, json_err = json.decode(content)                        if config and config.updater and config.updater[1] then                            remote_version = config.updater[1].version                            remote_path = config.updater[1].path                            success = true                            logToFile("Успешно загружен update_config.json, версия updater.luac: " .. tostring(remote_version) .. ", путь: " .. remote_path, "INFO")                        else                            logToFile("Ошибка: некорректная структура update_config.json", "ERROR")                        end                    else                        logToFile("Не удалось открыть " .. TEMP_JSON, "ERROR")                    end                else                    logToFile("Ошибка загрузки update_config.json: " .. tostring(err), "ERROR")                end            end        )        attempt = attempt + 1        wait(1000)    end    -- Удаление временного файла    if doesFileExist(TEMP_JSON) then        local success, err = pcall(os.remove, TEMP_JSON)        if not success then            logToFile("Ошибка удаления " .. TEMP_JSON .. ": " .. tostring(err), "ERROR")        end    end    if not success or not remote_version or not remote_path then        logToFile("Не удалось загрузить update_config.json после " .. max_attempts .. " попыток", "ERROR")        sampAddChatMessage("[UpdateUpdater] Не удалось загрузить конфигурацию обновления", 0xFF0000)        -- Самоудаление при ошибке        wait(1000)        local success, err = pcall(os.remove, THIS_SCRIPT_PATH)        if success then            logToFile("Скрипт update_updater.lua удалён (ошибка загрузки конфигурации)", "INFO")        else            logToFile("Ошибка удаления update_updater.lua: " .. tostring(err), "ERROR")            sampAddChatMessage("[UpdateUpdater] Ошибка удаления update_updater.lua", 0xFF0000)        end        flushLogBuffer()        return    end    -- Проверка версии    local local_version = local_versions.versions[UPDATER_NAME]    if isNewerVersion(local_version, remote_version) then        logToFile("Обнаружена новая версия updater.luac: " .. remote_version .. ", локальная версия: " .. tostring(local_version), "INFO")                -- Остановка updater.luac        if not unloadUpdater() then            -- Самоудаление при ошибке выгрузки            wait(1000)            local success, err = pcall(os.remove, THIS_SCRIPT_PATH)            if success then                logToFile("Скрипт update_updater.lua удалён (ошибка выгрузки)", "INFO")            else                logToFile("Ошибка удаления update_updater.lua: " .. tostring(err), "ERROR")                sampAddChatMessage("[UpdateUpdater] Ошибка удаления update_updater.lua", 0xFF0000)            end            flushLogBuffer()            return        end        -- Скачивание новой версии updater.luac        local download_success = false        downloadFile(            string.format("https://raw.githubusercontent.com/%s/%s/%s%s", GITHUB_USER, GITHUB_REPO, GITHUB_BRANCH, remote_path),            UPDATER_PATH,            UPDATER_NAME,            function(result, err)                if result then                    logToFile("Новая версия updater.luac успешно загружена и проверена по пути: " .. UPDATER_PATH, "INFO")                    sampAddChatMessage("[UpdateUpdater] Новая версия updater.luac загружена", 0x00FF00)                    download_success = true                    -- Обновление версии в versions.json                    local_versions.versions[UPDATER_NAME] = remote_version                    local_versions.is_updated = false -- Сбрасываем, чтобы основной скрипт проверил обновления                    saveJson(LOCAL_JSON, local_versions)                else                    logToFile("Ошибка загрузки updater.luac: " .. tostring(err), "ERROR")                    sampAddChatMessage("[UpdateUpdater] Ошибка загрузки updater.luac: " .. tostring(err), 0xFF0000)                end            end        )        -- Самоудаление после успешной загрузки        if download_success then            wait(1000) -- Задержка для надёжного завершения операций            local success, err = pcall(os.remove, THIS_SCRIPT_PATH)            if success then                logToFile("Скрипт update_updater.lua успешно удалён", "INFO")            else                logToFile("Ошибка удаления update_updater.lua: " .. tostring(err), "ERROR")                sampAddChatMessage("[UpdateUpdater] Ошибка удаления update_updater.lua", 0xFF0000)            end        end    else        logToFile("Обновление updater.luac не требуется: локальная версия " .. tostring(local_version) .. ", удалённая версия " .. remote_version, "INFO")        sampAddChatMessage("[UpdateUpdater] Обновление updater.luac не требуется", 0x00FF00)        -- Самоудаление, если обновление не требуется        wait(1000) -- Задержка для надёжного завершения операций        local success, err = pcall(os.remove, THIS_SCRIPT_PATH)        if success then            logToFile("Скрипт update_updater.lua удалён (обновление не требуется)", "INFO")        else            logToFile("Ошибка удаления update_updater.lua: " .. tostring(err), "ERROR")            sampAddChatMessage("[UpdateUpdater] Ошибка удаления update_updater.lua", 0xFF0000)        end    end    flushLogBuffer()end