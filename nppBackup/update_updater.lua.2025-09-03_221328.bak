require "lib.moonloader"local json = require "dkjson"local encoding = require 'encoding'encoding.default = 'CP1251'local u8 = encoding.UTF8-- Функция для корректного отображения кириллицыfunction to_utf8(str)    if type(str) ~= "string" then return str end    return u8:decode(str)end-- Функция логированияfunction ensureDirectoryExists(path)    local success, err = pcall(function()        os.execute('mkdir "' .. path .. '" 2>nul')    end)    if not success then        logToFile("Ошибка создания папки: " .. path .. ": " .. tostring(err))    endendfunction logToFile(message)    local game_dir = getGameDirectory()    local log_path = (game_dir or "") .. "\\moonloader\\LuaDunaevskiy\\"    ensureDirectoryExists(log_path)    local file = io.open(log_path .. "update_updater.log", "a")    if file then        file:write(os.date("[%Y-%m-%d %H:%M:%S] ") .. message .. "\n")        file:close()    endend-- Проверка счета игрокаfunction getPlayerScore()    local playerId = select(2, sampGetPlayerIdByCharHandle(PLAYER_PED))    if playerId then        return sampGetPlayerScore(playerId)    end    return 0end-- Функция загрузки файлаfunction downloadFile(url, save_path, callback)    local dlstatus = require('moonloader').download_status    logToFile("Попытка загрузки файла: " .. save_path)    local download_status = {}    download_status[save_path] = true    downloadUrlToFile(url, save_path, function(id, status, p1, p2)        if status == dlstatus.STATUSEX_ENDDOWNLOAD then            logToFile("Файл успешно загружен: " .. save_path)            download_status[save_path] = nil            callback(true)        elseif status == dlstatus.STATUSEX_ERROR then            logToFile("Ошибка загрузки файла: " .. tostring(p1))            download_status[save_path] = nil            callback(false, tostring(p1))        end    end)    local timeout = 30000    local start_time = os.clock()    while download_status[save_path] and (os.clock() - start_time) * 1000 < timeout do        wait(100)    end    if download_status[save_path] then        logToFile("Таймаут загрузки: " .. save_path)        download_status[save_path] = nil        callback(false, "Таймаут загрузки")    endend-- Функция сравнения версийfunction isNewerVersion(local_ver, remote_ver)    return not local_ver or local_ver ~= remote_verend-- Функция загрузки JSONfunction loadJson(file_path, default_data)    local game_dir = getGameDirectory()    if not game_dir then        logToFile("Ошибка: getGameDirectory вернул nil")        return default_data    end    local dir_path = game_dir .. "\\moonloader\\LuaDunaevskiy\\"    ensureDirectoryExists(dir_path)    local file = io.open(file_path, "rb")    if file then        local content = file:read("a"):gsub("^\239\187\191", "")        file:close()        local success, result = pcall(json.decode, content)        if success and result then            logToFile("Успешно загружен JSON: " .. file_path)            return result        else            logToFile("Ошибка декодирования JSON: " .. file_path .. ": " .. tostring(result))        end    else        logToFile("Файл JSON не найден: " .. file_path .. ", используется значение по умолчанию")    end    return default_dataend-- Функция сохранения JSONfunction saveJson(file_path, data)    local game_dir = getGameDirectory()    if not game_dir then        logToFile("Ошибка: getGameDirectory вернул nil при сохранении JSON")        return    end    local dir_path = game_dir .. "\\moonloader\\LuaDunaevskiy\\"    ensureDirectoryExists(dir_path)    local file = io.open(file_path, "w")    if file then        local success, err = pcall(function()            file:write(json.encode(data, { indent = true }))        end)        file:close()        if success then            logToFile("Успешно сохранён JSON: " .. file_path)        else            logToFile("Ошибка кодирования JSON: " .. file_path .. ": " .. tostring(err))        end    else        logToFile("Ошибка открытия файла для сохранения JSON: " .. file_path)    endendfunction main()    if not isSampLoaded() or not isSampfuncsLoaded() then        logToFile("SA:MP или sampfuncs не загружены")        sampAddChatMessage("[UpdateUpdater] SA:MP или sampfuncs не загружены", 0xFF0000)        return    end    local game_dir = getGameDirectory()    if not game_dir then        logToFile("Ошибка: getGameDirectory вернул nil")        sampAddChatMessage("[UpdateUpdater] Ошибка: не удалось определить игровую директорию", 0xFF0000)        return    end    local SAVE_PATH = game_dir .. "\\moonloader\\"    local VERSION_JSON = SAVE_PATH .. "LuaDunaevskiy\\version.json"    local TEMP_JSON = SAVE_PATH .. "LuaDunaevskiy\\temp_config.json"    local VERSIONS_JSON = SAVE_PATH .. "LuaDunaevskiy\\versions.json"    local UPDATER_NAME = "updater.luac"    local UPDATER_LUAC = SAVE_PATH .. "updater.luac"    -- Ждем авторизации игрока    while getPlayerScore() == 0 do        logToFile("Ожидание авторизации игрока (счет = 0)")        wait(1000)    end    logToFile("Игрок авторизован, счет: " .. getPlayerScore())    -- Загружаем локальные версии    local local_versions = loadJson(VERSION_JSON, { updater = {} })    local main_versions = loadJson(VERSIONS_JSON, { versions = {}, files = {}, libraries = {}, dev_versions = {}, descriptions = {}, commands = {}, update_complete = false })    -- Проверяем обновления    local GITHUB_USER = "egoist1313"    local GITHUB_REPO = "DunaevskiyLua"    local GITHUB_BRANCH = "main"    local max_attempts = 3    local remote_versions    local function tryDownload(url, temp_file, callback)        local attempt = 1        while attempt <= max_attempts do            logToFile("Попытка загрузки " .. url .. " #" .. attempt)            local download_done = false            local success, download_error            downloadFile(url, temp_file, function(result, err)                success = result                download_error = err                download_done = true            end)            local timeout = 30000            local start_time = os.clock()            while not download_done and (os.clock() - start_time) * 1000 < timeout do                wait(100)            end            if not download_done then                logToFile("Таймаут загрузки " .. temp_file)            elseif success then                local file = io.open(temp_file, "rb")                if file then                    local content = file:read("a"):gsub("^\239\187\191", ""):gsub("[\r\n]+$", "")                    file:close()                    if content == "" then                        logToFile("Пустое содержимое " .. temp_file)                        return false                    end                    local config, _, err = json.decode(content)                    if not config or err then                        logToFile("Ошибка парсинга " .. temp_file .. ": " .. tostring(err))                        return false                    end                    callback(config)                    return true                else                    logToFile("Не удалось открыть " .. temp_file)                    return false                end            else                logToFile("Ошибка загрузки " .. temp_file .. ": " .. tostring(download_error))            end            attempt = attempt + 1            wait(1000)        end        return false    end    local success = tryDownload(        string.format("https://raw.githubusercontent.com/%s/%s/%s/update_config.json", GITHUB_USER, GITHUB_REPO, GITHUB_BRANCH),        TEMP_JSON,        function(config)            remote_versions = config        end    )    if not success then        logToFile("Не удалось загрузить update_config.json после " .. max_attempts .. " попыток")        sampAddChatMessage("[UpdateUpdater] Не удалось загрузить конфигурацию обновления", 0xFF0000)        pcall(os.remove, TEMP_JSON)        -- Самоудаление в случае ошибки        local this_script = thisScript()        if this_script then            local success, err = pcall(this_script.unload, this_script)            if success then                logToFile("update_updater.lua успешно выгружен")                pcall(os.remove, SAVE_PATH .. "update_updater.lua")                logToFile("update_updater.lua удалён")            else                logToFile("Ошибка выгрузки update_updater.lua: " .. tostring(err))            end        end        return    end    pcall(os.remove, TEMP_JSON)    -- Проверяем updater    local updater_entry = remote_versions.updater    if not updater_entry or not updater_entry.name or not updater_entry.version or not updater_entry.path then        logToFile("Ошибка: некорректная структура записи для updater в update_config.json")        sampAddChatMessage("[UpdateUpdater] Ошибка: некорректная конфигурация для updater.luac", 0xFF0000)        -- Самоудаление в случае ошибки        local this_script = thisScript()        if this_script then            local success, err = pcall(this_script.unload, this_script)            if success then                logToFile("update_updater.lua успешно выгружен")                pcall(os.remove, SAVE_PATH .. "update_updater.lua")                logToFile("update_updater.lua удалён")            else                logToFile("Ошибка выгрузки update_updater.lua: " .. tostring(err))            end        end        return    end    if updater_entry.name ~= UPDATER_NAME then        logToFile("Ошибка: имя в update_config.json (" .. updater_entry.name .. ") не соответствует updater.luac")        sampAddChatMessage("[UpdateUpdater] Ошибка: некорректное имя в конфигурации", 0xFF0000)        -- Самоудаление в случае ошибки        local this_script = thisScript()        if this_script then            local success, err = pcall(this_script.unload, this_script)            if success then                logToFile("update_updater.lua успешно выгружен")                pcall(os.remove, SAVE_PATH .. "update_updater.lua")                logToFile("update_updater.lua удалён")            else                logToFile("Ошибка выгрузки update_updater.lua: " .. tostring(err))            end        end        return    end    local local_ver = local_versions.updater.version    local remote_ver = updater_entry.version    if isNewerVersion(local_ver, remote_ver) then        -- Ждем, пока update_complete станет true в versions.json        local max_wait_attempts = 30 -- Максимум 30 секунд ожидания        local wait_interval = 1000 -- 1 секунда между попытками        local attempts = 0        local main_versions = loadJson(VERSIONS_JSON, { update_complete = false })        while not main_versions.update_complete and attempts < max_wait_attempts do            logToFile("Ожидание завершения обновлений в updater.luac (попытка " .. (attempts + 1) .. "/" .. max_wait_attempts .. ")")            wait(wait_interval)            attempts = attempts + 1            main_versions = loadJson(VERSIONS_JSON, { update_complete = false })        end        if attempts >= max_wait_attempts then            logToFile("Таймаут ожидания update_complete в versions.json")            sampAddChatMessage("[UpdateUpdater] Таймаут ожидания updater.luac", 0xFF0000)            -- Самоудаление в случае таймаута            local this_script = thisScript()            if this_script then                local success, err = pcall(this_script.unload, this_script)                if success then                    logToFile("update_updater.lua успешно выгружен")                    pcall(os.remove, SAVE_PATH .. "update_updater.lua")                    logToFile("update_updater.lua удалён")                else                    logToFile("Ошибка выгрузки update_updater.lua: " .. tostring(err))                end            end            return        end        logToFile("update_complete = true, начинаем обновление updater.luac")        -- Выгружаем текущий updater.luac        local updater = script.find(UPDATER_NAME)        if updater then            local success, err = pcall(updater.unload, updater)            if success then                logToFile("updater.luac успешно выгружен")            else                logToFile("Ошибка выгрузки updater.luac: " .. tostring(err))            end            wait(2000) -- Пауза 2 секунды перед загрузкой        else            logToFile("updater.luac не найден, пропускаем выгрузку")            wait(2000) -- Пауза 2 секунды перед загрузкой        end        -- Загружаем новую версию        local file_path = SAVE_PATH .. updater_entry.path:gsub("/", "\\")        local url = string.format("https://raw.githubusercontent.com/%s/%s/%s/%s", GITHUB_USER, GITHUB_REPO, GITHUB_BRANCH, updater_entry.path)        downloadFile(url, file_path, function(success, err)            if success then                -- Обновляем версию в version.json только после успешной загрузки                local_versions.updater = {                    version = remote_ver,                    description = updater_entry.description or "Основной скрипт обновления",                    command = updater_entry.command or "/DunLua"                }                saveJson(VERSION_JSON, local_versions)                logToFile("Обновлен скрипт updater.luac до версии " .. remote_ver)                sampAddChatMessage("[UpdateUpdater] Обновлен updater.luac до версии " .. remote_ver, 0x00FF00)                -- Запускаем новый updater.luac                local success, err = pcall(script.load, updater_entry.path:gsub("/", "\\"))                if success then                    logToFile("updater.luac успешно перезапущен")                else                    logToFile("Ошибка перезапуска updater.luac: " .. tostring(err))                    sampAddChatMessage("[UpdateUpdater] Ошибка перезапуска updater.luac", 0xFF0000)                end            else                logToFile("Ошибка загрузки updater.luac: " .. tostring(err))                sampAddChatMessage("[UpdateUpdater] Ошибка загрузки updater.luac: " .. tostring(err), 0xFF0000)                if doesFileExist(file_path) then pcall(os.remove, file_path) end            end            -- Самоудаление скрипта            local this_script = thisScript()            if this_script then                local success, err = pcall(this_script.unload, this_script)                if success then                    logToFile("update_updater.lua успешно выгружен")                    pcall(os.remove, SAVE_PATH .. "update_updater.lua")                    logToFile("update_updater.lua удалён")                else                    logToFile("Ошибка выгрузки update_updater.lua: " .. tostring(err))                end            end        end)    else        logToFile("updater.luac уже актуален (версия: " .. (local_ver or "неизвестно") .. ")")        sampAddChatMessage("[UpdateUpdater] updater.luac уже актуален", 0x00FF00)        -- Самоудаление скрипта        local this_script = thisScript()        if this_script then            local success, err = pcall(this_script.unload, this_script)            if success then                logToFile("update_updater.lua успешно выгружен")                pcall(os.remove, SAVE_PATH .. "update_updater.lua")                logToFile("update_updater.lua удалён")            else                logToFile("Ошибка выгрузки update_updater.lua: " .. tostring(err))            end        end    endend