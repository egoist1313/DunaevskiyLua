local script_author = 'Alex_Swift'local script_version = '2.3.6'require "lib.moonloader"local json = require "dkjson"local encoding = require 'encoding'encoding.default = 'CP1251'local u8 = encoding.UTF8-- Константыlocal GITHUB_USER = "egoist1313"local GITHUB_REPO = "DunaevskiyLua"local GITHUB_BRANCH = "test"local SAVE_PATH = getGameDirectory() .. "\\moonloader\\"local scripts_dir_rel = "LuaDunaevskiy"local LOCAL_JSON = SAVE_PATH .. "LuaDunaevskiy\\versions.json"local TEMP_JSON = SAVE_PATH .. "LuaDunaevskiy\\update_config.json"local UPDATER_NAME = "updater.luac"local UPDATER_NAME_NO_EXT = "updater"local UPDATER_PATH = SAVE_PATH .. "LuaDunaevskiy\\" .. UPDATER_NAMElocal THIS_SCRIPT_NAME = "update_updater.lua"local THIS_SCRIPT_PATH = SAVE_PATH .. "LuaDunaevskiy\\" .. THIS_SCRIPT_NAMElocal LOG_PATH = SAVE_PATH .. "LuaDunaevskiy\\update_updater.log"local MAX_WAIT_TIME = 300000 -- 5 минутlocal DOWNLOAD_TIMEOUT = 90000 -- 90 секунд-- Логированиеlocal log_buffer = {}function logToFile(message, level)    level = level or "INFO"    table.insert(log_buffer, os.date("[%Y-%m-%d %H:%M:%S] ") .. "[" .. level .. "] " .. message)    if #log_buffer >= 10 then        flushLogBuffer()    endendfunction flushLogBuffer()    if #log_buffer > 0 then        local file = io.open(LOG_PATH, "a")        if file then            for _, msg in ipairs(log_buffer) do                file:write(msg .. "\n")            end            file:close()            log_buffer = {}        else            sampAddChatMessage("[UpdateUpdater] Ошибка записи лога", 0xFF0000)        end    endendfunction clearLogFile()    local success, err = pcall(os.remove, LOG_PATH)    if success then        logToFile("Лог-файл очищен", "INFO")    else        logToFile("Ошибка очистки лога: " .. tostring(err), "ERROR")        sampAddChatMessage("[UpdateUpdater] Ошибка очистки лога", 0xFF0000)    endendfunction ensureDirectoryExists(path)    local success, err = pcall(function()        os.execute('mkdir "' .. path .. '" 2>nul')        local file = io.open(path .. "test_access.txt", "w")        if file then            file:write("test")            file:close()            os.remove(path .. "test_access.txt")        end    end)    if not success then        logToFile("Ошибка доступа к папке: " .. path .. ": " .. tostring(err), "ERROR")        sampAddChatMessage("[UpdateUpdater] Нет доступа к папке: " .. path, 0xFF0000)        return false    end    return trueend-- Функция загрузки JSONfunction loadJson(file_path, default_data)    if not file_path then        logToFile("Ошибка: file_path is nil", "ERROR")        return default_data    end    local file_exists = doesFileExist(file_path)    logToFile("Проверка существования файла " .. file_path .. ": " .. tostring(file_exists), "INFO")    if not file_exists then        logToFile("Файл JSON не найден: " .. file_path, "INFO")        return default_data    end    local file = io.open(file_path, "rb")    if file then        local content = file:read("a"):gsub("^\239\187\191", "")        file:close()        if not content or content == "" then            logToFile("Содержимое файла " .. file_path .. " пустое", "ERROR")            return default_data        end        logToFile("Содержимое файла " .. file_path .. ": " .. content, "INFO")        local success, result = pcall(json.decode, content)        if success and result then            logToFile("Успешно загружен JSON: " .. file_path, "INFO")            return result        else            logToFile("Ошибка декодирования JSON: " .. file_path .. ": " .. tostring(result), "ERROR")            return default_data        end    else        logToFile("Не удалось открыть файл " .. file_path, "ERROR")        return default_data    endend-- Функция сохранения JSONfunction saveJson(file_path, data)    if not file_path then        logToFile("Ошибка: file_path is nil", "ERROR")        return    end    local dir_path = file_path:match("^(.*\\)[^\\]+$")    if dir_path and not ensureDirectoryExists(dir_path) then return end    local file = io.open(file_path, "w")    if file then        local success, err = pcall(function()            file:write(json.encode(data, { indent = true }))        end)        file:close()        if not success then            logToFile("Ошибка кодирования JSON: " .. file_path .. ": " .. tostring(err), "ERROR")        end    else        logToFile("Ошибка открытия файла для сохранения JSON: " .. file_path, "ERROR")    endend-- Функция сравнения версийfunction isNewerVersion(local_ver, remote_ver)    local success, result = pcall(function()        if not local_ver then return true end        local l_parts = { local_ver:match("(%d+)%.(%d+)%.(%d+)") }        local r_parts = { remote_ver:match("(%d+)%.(%d+)%.(%d+)") }        if not l_parts[1] or not r_parts[1] then return local_ver ~= remote_ver end        for i = 1, 3 do            local l_num, r_num = tonumber(l_parts[i]) or 0, tonumber(r_parts[i]) or 0            if l_num < r_num then return true end            if l_num > r_num then return false end        end        return false    end)    if not success then        logToFile("Ошибка сравнения версий: " .. tostring(result), "ERROR")        return false    end    return resultend-- Функция загрузки файлаfunction downloadFile(url, save_path, name, callback)    logToFile("Попытка загрузки файла: " .. name, "INFO")    local dir_path = save_path:match("^(.*\\)[^\\]+$")    if dir_path and not ensureDirectoryExists(dir_path) then        logToFile("Невозможно начать загрузку: некорректный путь " .. dir_path, "ERROR")        callback(false, nil, "Некорректный путь")        return    end    local start_time = os.clock()    downloadUrlToFile(url, save_path, function(id, status, p1, p2)        if status == require('moonloader').download_status.STATUSEX_ENDDOWNLOAD then            logToFile("Файл " .. name .. " загружен", "INFO")            local file_exists = doesFileExist(save_path)            logToFile("Проверка файла " .. save_path .. ": " .. tostring(file_exists), "INFO")            callback(file_exists, save_path, file_exists and nil or "Файл не найден")        elseif status == require('moonloader').download_status.STATUSEX_ERROR then            logToFile("Ошибка загрузки " .. name .. ": " .. tostring(p1), "ERROR")            callback(false, nil, tostring(p1))        elseif (os.clock() - start_time) * 1000 > DOWNLOAD_TIMEOUT then            logToFile("Таймаут загрузки файла " .. name, "ERROR")            callback(false, nil, "Таймаут загрузки")        else            logToFile("Статус загрузки " .. name .. ": " .. tostring(status), "DEBUG")        end    end)end-- Функция выгрузки скриптаfunction unloadUpdater()    local max_attempts = 3    local attempt = 1    local updater_handle = script.find(UPDATER_NAME) or script.find(UPDATER_NAME_NO_EXT)    while updater_handle and attempt <= max_attempts do        local success, result = pcall(updater_handle.unload, updater_handle)        if success then            wait(1000)            updater_handle = script.find(UPDATER_NAME) or script.find(UPDATER_NAME_NO_EXT)            if not updater_handle then                logToFile("Скрипт updater.luac выгружен", "INFO")                sampAddChatMessage("[UpdateUpdater] Скрипт updater.luac выгружен", 0x00FF00)                return true            end        else            logToFile("Ошибка выгрузки updater.luac: " .. tostring(result), "ERROR")        end        attempt = attempt + 1    end    logToFile("Не удалось выгрузить updater.luac, продолжаем обновление", "WARN")    sampAddChatMessage("[UpdateUpdater] Не удалось выгрузить updater.luac, продолжаем обновление", 0xFFFF00)    return falseend-- Функция запуска updater.luacfunction launchUpdater()    local success, result = pcall(script.load, UPDATER_PATH)    if success then        logToFile("Скрипт updater.luac запущен", "INFO")        sampAddChatMessage("[UpdateUpdater] Скрипт updater.luac запущен", 0x00FF00)        return true    else        logToFile("Ошибка запуска updater.luac: " .. tostring(result), "ERROR")        sampAddChatMessage("[UpdateUpdater] Ошибка запуска updater.luac", 0xFF0000)        return false    endend-- Функция обновленияfunction performUpdate()    local success, err = pcall(function()        logToFile("Начало performUpdate", "INFO")        local remote_version, remote_path        local max_attempts = 3        local attempt = 1        local download_complete = false        -- Функция для обработки загрузки update_config.json        local function tryDownloadConfig()            if attempt > max_attempts then                logToFile("Не удалось загрузить update_config.json после " .. max_attempts .. " попыток", "ERROR")                sampAddChatMessage("[UpdateUpdater] Не удалось загрузить конфигурацию", 0xFF0000)                return false            end            logToFile("Попытка загрузки update_config.json #" .. attempt, "INFO")            downloadFile(                string.format("https://raw.githubusercontent.com/%s/%s/%s/update_config.json", GITHUB_USER, GITHUB_REPO, GITHUB_BRANCH),                TEMP_JSON,                "update_config.json",                function(result, save_path, err)                    if result then                        local file_success, file_err = pcall(function()                            local file = io.open(save_path, "rb")                            if not file then                                logToFile("Не удалось открыть файл " .. save_path, "ERROR")                                error("Не удалось открыть файл")                            end                            local content = file:read("a")                            file:close()                            if not content or content == "" then                                logToFile("Содержимое файла " .. save_path .. " пустое", "ERROR")                                error("Пустое содержимое файла")                            end                            content = content:gsub("^\239\187\191", ""):gsub("[\r\n]+$", "")                            logToFile("Содержимое update_config.json: " .. content, "INFO")                            local config, _, json_err = json.decode(content)                            if not config then                                logToFile("Ошибка декодирования JSON: " .. tostring(json_err), "ERROR")                                error("Ошибка декодирования JSON")                            end                            if config and config.updater and config.updater[1] then                                remote_version = config.updater[1].version                                remote_path = config.updater[1].path                                if not remote_path:match("%.luac$") then                                    logToFile("Ошибка: неверный путь в JSON: " .. remote_path, "ERROR")                                    error("Неверный путь в JSON")                                end                                logToFile("Успешно загружен update_config.json, версия: " .. tostring(remote_version), "INFO")                            else                                logToFile("Ошибка: некорректная структура JSON", "ERROR")                                error("Некорректная структура JSON")                            end                            local remove_success, remove_err = pcall(os.remove, save_path)                            if not remove_success then                                logToFile("Ошибка удаления " .. save_path .. ": " .. tostring(remove_err), "ERROR")                            end                        end)                        if file_success then                            download_complete = true                        else                            logToFile("Ошибка обработки файла " .. save_path .. ": " .. tostring(file_err), "ERROR")                            attempt = attempt + 1                            wait(1000)                            tryDownloadConfig()                        end                    else                        logToFile("Ошибка загрузки update_config.json: " .. tostring(err), "ERROR")                        attempt = attempt + 1                        wait(1000)                        tryDownloadConfig()                    end                end            )        end        tryDownloadConfig()        -- Ожидание завершения загрузки        local start_time = os.clock()        while not download_complete and (os.clock() - start_time) * 1000 < DOWNLOAD_TIMEOUT do            wait(100)        end        if not download_complete or not remote_version or not remote_path then            logToFile("Не удалось загрузить update_config.json", "ERROR")            sampAddChatMessage("[UpdateUpdater] Не удалось загрузить конфигурацию", 0xFF0000)            flushLogBuffer()            return        end        logToFile("Чтение versions.json", "INFO")        local local_versions        local version_success, version_err = pcall(function()            local_versions = loadJson(LOCAL_JSON, { versions = {}, is_updated = false })            if not local_versions or not local_versions.versions then                logToFile("Ошибка: некорректная структура versions.json", "ERROR")                error("Некорректная структура versions.json")            end        end)        if not version_success then            logToFile("Ошибка чтения versions.json: " .. tostring(version_err), "ERROR")            sampAddChatMessage("[UpdateUpdater] Ошибка чтения versions.json", 0xFF0000)            flushLogBuffer()            return        end        local local_version = local_versions.versions[UPDATER_NAME]        logToFile("Локальная версия: " .. tostring(local_version) .. ", удалённая версия: " .. tostring(remote_version), "INFO")        local newer_success, is_newer = pcall(isNewerVersion, local_version, remote_version)        if not newer_success then            logToFile("Ошибка сравнения версий: " .. tostring(is_newer), "ERROR")            sampAddChatMessage("[UpdateUpdater] Ошибка сравнения версий", 0xFF0000)            flushLogBuffer()            return        end        if is_newer then            logToFile("Обнаружена новая версия updater.luac: " .. remote_version, "INFO")            unloadUpdater()            local download_success = false            downloadFile(                string.format("https://raw.githubusercontent.com/%s/%s/%s/%s", GITHUB_USER, GITHUB_REPO, GITHUB_BRANCH, remote_path),                UPDATER_PATH,                UPDATER_NAME,                function(result, save_path, err)                    if result then                        logToFile("Новая версия updater.luac загружена", "INFO")                        sampAddChatMessage("[UpdateUpdater] Новая версия updater.luac загружена", 0x00FF00)                        download_success = true                        local_versions.versions[UPDATER_NAME] = remote_version                        saveJson(LOCAL_JSON, local_versions)                        launchUpdater()                    else                        logToFile("Ошибка загрузки updater.luac: " .. tostring(err), "ERROR")                        sampAddChatMessage("[UpdateUpdater] Ошибка загрузки updater.luac", 0xFF0000)                    end                end            )            -- Ожидание завершения загрузки updater.luac            start_time = os.clock()            while not download_success and (os.clock() - start_time) * 1000 < DOWNLOAD_TIMEOUT do                wait(100)            end            if not download_success then                logToFile("Не удалось загрузить updater.luac", "ERROR")                sampAddChatMessage("[UpdateUpdater] Не удалось загрузить updater.luac", 0xFF0000)                flushLogBuffer()                return            end        else            logToFile("Обновление updater.luac не требуется", "INFO")            sampAddChatMessage("[UpdateUpdater] Обновление updater.luac не требуется", 0x00FF00)        end    end)    if not success then        logToFile("Ошибка в performUpdate: " .. tostring(err), "ERROR")        sampAddChatMessage("[UpdateUpdater] Ошибка обновления: " .. tostring(err), 0xFF0000)    end    wait(1000)    local success, err = pcall(os.remove, THIS_SCRIPT_PATH)    if success then        logToFile("Скрипт update_updater.lua удалён", "INFO")    else        logToFile("Ошибка удаления update_updater.lua: " .. tostring(err), "ERROR")        sampAddChatMessage("[UpdateUpdater] Ошибка удаления update_updater.lua", 0xFF0000)    end    flushLogBuffer()end-- Основная функцияfunction main()    if not isSampLoaded() or not isSampfuncsLoaded() then        logToFile("SA:MP или sampfuncs не загружены", "ERROR")        sampAddChatMessage("[UpdateUpdater] SA:MP или sampfuncs не загружены", 0xFF0000)        flushLogBuffer()        return    end    clearLogFile() -- Очистка лога при запуске    while not isSampAvailable() do wait(100) end    if not ensureDirectoryExists(SAVE_PATH .. scripts_dir_rel .. "\\") then        flushLogBuffer()        return    end    local local_versions = loadJson(LOCAL_JSON, { versions = {}, is_updated = false })    local start_time = os.clock()    while not local_versions.is_updated and (os.clock() - start_time) * 1000 < MAX_WAIT_TIME do        wait(2000)        local_versions = loadJson(LOCAL_JSON, { versions = {}, is_updated = false })    end    if not local_versions.is_updated then        logToFile("Таймаут ожидания is_updated", "ERROR")        sampAddChatMessage("[UpdateUpdater] Таймаут ожидания обновлений", 0xFF0000)        wait(1000)        local success, err = pcall(os.remove, THIS_SCRIPT_PATH)        if success then            logToFile("Скрипт update_updater.lua удалён", "INFO")        else            logToFile("Ошибка удаления update_updater.lua: " .. tostring(err), "ERROR")            sampAddChatMessage("[UpdateUpdater] Ошибка удаления update_updater.lua", 0xFF0000)        end        flushLogBuffer()        return    end    logToFile("is_updated == true, начинаем обновление", "INFO")    performUpdate()end