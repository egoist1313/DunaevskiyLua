script_name('ScriptUpdater')
script_author('Alex_Swift')
local script_version = '2.0.0'
script_properties("work-in-pause")
require "lib.moonloader"
local json = require "dkjson"
local encoding = require 'encoding'
local lfs = require("lfs")
local imgui = require 'mimgui'
local vkeys = require 'vkeys'
local dlstatus = require('moonloader').download_status
local ffi = require 'ffi'
encoding.default = 'CP1251'
local u8 = encoding.UTF8

-- Функция для корректного отображения кириллицы в ImGui
function to_utf8(str)
    if type(str) ~= "string" then return str end
    return u8:decode(str)
end

-- Функция логирования
function ensureDirectoryExists(path)
    local success, err = pcall(function()
        os.execute('mkdir "' .. path .. '" 2>nul')
    end)
    if not success then
        sampAddChatMessage("[Updater] Не удалось создать папку: " .. path, 0xFF0000)
        logToFile("Ошибка создания папки: " .. path .. ": " .. tostring(err))
    end
end

function logToFile(message)
    local log_path = (getGameDirectory() or "") .. "\\moonloader\\LuaDunaevskiy\\"
    ensureDirectoryExists(log_path)
    local file = io.open(log_path .. "updater.log", "a")
    if file then
        file:write(os.date("[%Y-%m-%d %H:%M:%S] ") .. message .. "\n")
        file:close()
    end
end

function clearLogFile()
    local log_path = (getGameDirectory() or "") .. "\\moonloader\\LuaDunaevskiy\\"
    ensureDirectoryExists(log_path)
    local file = io.open(log_path .. "updater.log", "w")
    if file then
        file:write("")
        file:close()
    end
end

-- Проверка загрузки mimgui
if imgui == nil then
    logToFile("Ошибка: mimgui не загружен")
    return
end

-- Проверка, запущен ли скрипт
local is_script_running = false
if is_script_running then
    return
end
is_script_running = true

-- Определение функций Windows API через FFI
ffi.cdef[[
    void* CreateToolhelp32Snapshot(uint32_t dwFlags, uint32_t th32ProcessID);
    bool Process32First(void* hSnapshot, struct PROCESSENTRY32* lppe);
    bool Process32Next(void* hSnapshot, struct PROCESSENTRY32* lppe);
    bool CloseHandle(void* hObject);
    void* OpenProcess(uint32_t dwDesiredAccess, bool bInheritHandle, uint32_t dwProcessId);
    bool TerminateProcess(void* hProcess, uint32_t uExitCode);
    struct PROCESSENTRY32 {
        uint32_t dwSize;
        uint32_t cntUsage;
        uint32_t th32ProcessID;
        void* th32DefaultHeapID;
        uint32_t th32ModuleID;
        uint32_t cntThreads;
        uint32_t th32ParentProcessID;
        int32_t pcPriClassBase;
        uint32_t dwFlags;
        char szExeFile[260];
    };
]]

-- Функция проверки существования процесса
function isProcessRunning(processName)
    local snapshot = ffi.C.CreateToolhelp32Snapshot(0x2, 0)
    if snapshot == ffi.cast("void*", -1) then
        logToFile("Ошибка создания снимка процессов")
        return false
    end
    local pe = ffi.new("struct PROCESSENTRY32")
    pe.dwSize = ffi.sizeof(pe)
    if ffi.C.Process32First(snapshot, pe) then
        repeat
            if ffi.string(pe.szExeFile):lower() == processName:lower() then
                ffi.C.CloseHandle(snapshot)
                return true
            end
        until not ffi.C.Process32Next(snapshot, pe)
    end
    ffi.C.CloseHandle(snapshot)
    return false
end

-- Функция завершения процесса
function killProcess(processName)
    local snapshot = ffi.C.CreateToolhelp32Snapshot(0x2, 0)
    if snapshot == ffi.cast("void*", -1) then
        logToFile("Ошибка создания снимка процессов")
        return false
    end
    local pe = ffi.new("struct PROCESSENTRY32")
    pe.dwSize = ffi.sizeof(pe)
    if ffi.C.Process32First(snapshot, pe) then
        repeat
            if ffi.string(pe.szExeFile):lower() == processName:lower() then
                local processHandle = ffi.C.OpenProcess(1, false, pe.th32ProcessID)
                if processHandle ~= nil then
                    ffi.C.TerminateProcess(processHandle, 0)
                    ffi.C.CloseHandle(processHandle)
                    ffi.C.CloseHandle(snapshot)
                    return true
                end
            end
        until not ffi.C.Process32Next(snapshot, pe)
    end
    ffi.C.CloseHandle(snapshot)
    return false
end

-- Универсальная функция загрузки JSON
function loadJson(file_path, default_data)
    local game_dir = getGameDirectory()
    if not game_dir then
        logToFile("Ошибка: getGameDirectory вернул nil")
        return default_data
    end
    local dir_path = game_dir .. "\\moonloader\\LuaDunaevskiy\\"
    ensureDirectoryExists(dir_path)
    local file = io.open(file_path, "rb")
    if file then
        local content = file:read("*a"):gsub("^\239\187\191", "")
        file:close()
        local success, result = pcall(json.decode, content)
        if success and result then
            logToFile("Успешно загружен JSON: " .. file_path)
            if file_path:match("enabled%.json$") then
                local converted_data = {}
                for key, value in pairs(result) do
                    if type(value) == "boolean" then
                        converted_data[key] = imgui.new.bool(value)
                    else
                        logToFile("Некорректное значение в enabled.json для ключа " .. key .. ": " .. tostring(value))
                        converted_data[key] = imgui.new.bool(false)
                    end
                end
                return converted_data
            end
            return result
        else
            logToFile("Ошибка декодирования JSON: " .. file_path .. ": " .. tostring(result))
        end
    else
        logToFile("Файл JSON не найден: " .. file_path .. ", используется значение по умолчанию")
    end
    return default_data
end

-- Универсальная функция сохранения JSON
function saveJson(file_path, data)
    local game_dir = getGameDirectory()
    if not game_dir then
        logToFile("Ошибка: getGameDirectory вернул nil при сохранении JSON")
        return
    end
    local dir_path = game_dir .. "\\moonloader\\LuaDunaevskiy\\"
    ensureDirectoryExists(dir_path)
    local file = io.open(file_path, "w")
    if file then
        local success, err
        if file_path:match("enabled%.json$") then
            local serialized_data = {}
            for key, value in pairs(data) do
                serialized_data[key] = value[0]
            end
            success, err = pcall(function()
                file:write(json.encode(serialized_data, { indent = true }))
            end)
        else
            success, err = pcall(function()
                file:write(json.encode(data, { indent = true }))
            end)
        end
        file:close()
        if success then
            logToFile("Успешно сохранён JSON: " .. file_path)
        else
            logToFile("Ошибка кодирования JSON: " .. file_path .. ": " .. tostring(err))
        end
    else
        logToFile("Ошибка открытия файла для сохранения JSON: " .. file_path)
    end
end

-- Функция загрузки файлов
function downloadFile(url, save_path, callback)
    logToFile("Попытка загрузки файла: " .. save_path)
    downloadUrlToFile(url, save_path, function(id, status, p1, p2)
        if status == dlstatus.STATUSEX_ENDDOWNLOAD then
            logToFile("Файл успешно загружен: " .. save_path)
            callback(true)
        elseif status == dlstatus.STATUSEX_ERROR then
            logToFile("Ошибка загрузки файла: " .. tostring(p1))
            callback(false, tostring(p1))
        end
    end)
end

function isNewerVersion(local_ver, remote_ver)
    return not local_ver or local_ver ~= remote_ver
end

function createDirectoriesForPath(file_path)
    local dir_path = file_path:match("^(.*\\)[^\\]+$")
    if dir_path then
        local parts = {}
        for part in dir_path:gmatch("[^\\]+") do
            table.insert(parts, part)
        end
        local current_path = ""
        for i, part in ipairs(parts) do
            current_path = current_path .. part .. "\\"
            ensureDirectoryExists(current_path)
        end
    end
end

-- Определение констант
local GITHUB_USER = "egoist1313"
local GITHUB_REPO = "DunaevskiyLua"
local GITHUB_BRANCH = "main"
local SAVE_PATH = getGameDirectory() .. "\\moonloader\\"
local scripts_dir_rel = "LuaDunaevskiy"
local scripts_dir_abs = SAVE_PATH .. scripts_dir_rel .. "\\"
local LOCAL_JSON = SAVE_PATH .. "LuaDunaevskiy\\versions.json"
local ENABLED_JSON = SAVE_PATH .. "LuaDunaevskiy\\enabled.json"
local TEMP_JSON = SAVE_PATH .. "LuaDunaevskiy\\temp_config.json"
local DEV_TEMP_JSON = SAVE_PATH .. "LuaDunaevskiy\\temp_development.json"
local UPDATER_NAME = "updater.lua"
local local_versions = loadJson(LOCAL_JSON, { versions = {}, files = {}, libraries = {}, dev_versions = {}, descriptions = {}, commands = {} })
local dev_versions = { versions = local_versions.dev_versions or {}, descriptions = {}, commands = {} }
local enabled_scripts = loadJson(ENABLED_JSON, {})
local remote_versions, development_versions
local updater_updated = false
local showMenu = imgui.new.bool(false)
local download_complete = false
local active_tab = imgui.new.int(0)
local download_status = {}
local is_checking_updates = false

-- Функция проверки IP сервера и ника игрока
function getMyNick()
    return sampGetPlayerNickname(select(2, sampGetPlayerIdByCharHandle(PLAYER_PED)))
end

function isPlayerAllowed()
    if not remote_versions or not development_versions then return false end
    local serverIP = sampGetCurrentServerAddress()
    local playerName = getMyNick() or ""
    local allowedIPs = development_versions.allowedIPs or {}
    local allowedPlayer = development_versions.allowedPlayer or ""
    for _, ip in ipairs(allowedIPs) do
        if serverIP == ip or serverIP:match(ip) then
            return playerName == allowedPlayer
        end
    end
    return false
end

-- Универсальная функция обработки элементов
function processItems(items, local_data, category, callback)
    local updated = false
    local new_data = { versions = {}, descriptions = local_versions.descriptions, commands = local_versions.commands }
    for _, entry in ipairs(items or {}) do
        if not entry.name or not entry.version or not entry.path then
            logToFile("Некорректная структура записи в " .. category)
        else
            local local_ver = local_data[entry.name]
            -- Для updater.lua сравниваем с script_version
            local remote_ver = (entry.name == UPDATER_NAME) and script_version or entry.version
            if isNewerVersion(local_ver, remote_ver) then
                local file_path = SAVE_PATH .. entry.path:gsub("/", "\\")
                createDirectoriesForPath(file_path)
                local url = string.format("https://raw.githubusercontent.com/%s/%s/%s/%s", GITHUB_USER, GITHUB_REPO, GITHUB_BRANCH, entry.path)
                download_status[entry.name] = true
                local success, download_error
                local download_done = false
                downloadFile(url, file_path, function(result, err)
                    success = result
                    download_error = err
                    download_done = true
                    download_status[entry.name] = nil
                end)
                local timeout = 30000
                local start_time = os.clock()
                while not download_done and (os.clock() - start_time) * 1000 < timeout do
                    wait(100)
                end
                if not download_done then
                    logToFile("Таймаут загрузки " .. category .. ": " .. entry.name)
                elseif success then
                    new_data.versions[entry.name] = remote_ver
                    if entry.description then new_data.descriptions[entry.name] = entry.description end
                    if entry.command then new_data.commands[entry.name] = entry.command end
                    logToFile("Обновлен " .. category .. " " .. entry.name .. " до версии " .. remote_ver)
                    sampAddChatMessage("[Updater] Обновлен " .. category .. " " .. entry.name .. " до версии " .. remote_ver, 0x00FF00)
                    updated = true
                    if category == "скрипт" and entry.name == UPDATER_NAME then
                        updater_updated = true
                        -- Перезапуск скрипта
                        local success, err = pcall(function()
                            script.load(file_path)
                        end)
                        if not success then
                            logToFile("Ошибка перезапуска скрипта " .. entry.name .. ": " .. tostring(err))
                        else
                            logToFile("Скрипт " .. entry.name .. " перезапущен")
                            sampAddChatMessage("[Updater] Скрипт " .. entry.name .. " перезапущен", 0x00FF00)
                        end
                    end
                    if entry.run_after_download then
                        local process_name = entry.name:lower()
                        if isProcessRunning(process_name) then killProcess(process_name) end
                        local dir_path = file_path:match("^(.*\\)[^\\]+$") or SAVE_PATH
                        local success, err = pcall(function()
                            os.execute('cd /d "' .. dir_path .. '" && start /min "" "' .. file_path .. '"')
                        end)
                        if not success then
                            logToFile("Ошибка запуска файла " .. file_path .. ": " .. tostring(err))
                        end
                    end
                else
                    logToFile("Ошибка загрузки " .. category .. " " .. entry.name .. ": " .. tostring(download_error))
                    if doesFileExist(file_path) then pcall(os.remove, file_path) end
                end
            else
                new_data.versions[entry.name] = local_data[entry.name] or remote_ver
                new_data.descriptions[entry.name] = local_versions.descriptions[entry.name]
                if category == "скрипт" then
                    new_data.commands[entry.name] = local_versions.commands[entry.name]
                end
            end
        end
    end
    callback(new_data, updated)
end

function downloadUpdates()
    logToFile("Начало downloadUpdates")
    if not remote_versions or type(remote_versions) ~= "table" then
        logToFile("remote_versions не определено")
        sampAddChatMessage("[Updater] Нет данных для обновления", 0xFF0000)
        return
    end
    local updated_scripts, updated_files, updated_libraries = false, false, false
    local new_versions = {
        versions = {},
        files = {},
        libraries = {},
        dev_versions = local_versions.dev_versions or {},
        descriptions = local_versions.descriptions,
        commands = local_versions.commands
    }
    processItems(remote_versions.scripts, local_versions.versions, "скрипт", function(data, updated)
        new_versions.versions = data.versions
        updated_scripts = updated
    end)
    processItems(remote_versions.files, local_versions.files, "файл", function(data, updated)
        new_versions.files = data.versions
        updated_files = updated
    end)
    processItems(remote_versions.libraries, local_versions.libraries, "библиотека", function(data, updated)
        new_versions.libraries = data.versions
        updated_libraries = updated
    end)
    if development_versions and development_versions.scripts and isPlayerAllowed() then
        processItems(development_versions.scripts, local_versions.dev_versions or {}, "скрипт разработки", function(data, updated)
            new_versions.dev_versions = data.versions
            new_versions.descriptions = data.descriptions
            new_versions.commands = data.commands
            updated_scripts = updated or updated_scripts
        end)
    end
    local function cleanOldItems(local_data, remote_items, category)
        local remote_names = {}
        for _, entry in ipairs(remote_items or {}) do
            if entry.name then remote_names[entry.name] = true end
        end
        for name in pairs(local_data or {}) do
            if not remote_names[name] then
                local file_path = SAVE_PATH .. (local_versions.paths and local_versions.paths[name] or "LuaDunaevskiy\\" .. name):gsub("/", "\\")
                if doesFileExist(file_path) then pcall(os.remove, file_path) end
            elseif not new_versions[category][name] then
                new_versions[category][name] = local_data[name]
                new_versions.descriptions[name] = local_versions.descriptions[name]
                if category == "versions" or category == "dev_versions" then
                    new_versions.commands[name] = local_versions.commands[name]
                end
            end
        end
    end
    cleanOldItems(local_versions.versions, remote_versions.scripts, "versions")
    cleanOldItems(local_versions.files, remote_versions.files, "files")
    cleanOldItems(local_versions.libraries, remote_versions.libraries, "libraries")
    cleanOldItems(local_versions.dev_versions or {}, development_versions and development_versions.scripts or {}, "dev_versions")
    enabled_scripts = loadJson(ENABLED_JSON, {})
    if not enabled_scripts then
        enabled_scripts = {}
        logToFile("enabled_scripts установлено в пустую таблицу из-за ошибки загрузки")
    end
    for _, entry in ipairs(remote_versions.scripts or {}) do
        if entry.name and entry.name ~= UPDATER_NAME then
            if not enabled_scripts[entry.name] then
                enabled_scripts[entry.name] = imgui.new.bool(false)
                logToFile("Новый скрипт " .. entry.name .. " добавлен в enabled_scripts с состоянием false")
            end
        end
    end
    if development_versions and development_versions.scripts and isPlayerAllowed() then
        for _, entry in ipairs(development_versions.scripts) do
            if entry.name and entry.name ~= UPDATER_NAME then
                if not enabled_scripts[entry.name] then
                    enabled_scripts[entry.name] = imgui.new.bool(false)
                    logToFile("Новый скрипт разработки " .. entry.name .. " добавлен в enabled_scripts с состоянием false")
                end
            end
        end
    end
    saveJson(ENABLED_JSON, enabled_scripts)
    local_versions = new_versions
    saveJson(LOCAL_JSON, local_versions)
    if doesFileExist(TEMP_JSON) then pcall(os.remove, TEMP_JSON) end
    if updated_scripts or updated_files or updated_libraries then
        logToFile("Обновлены скрипты: " .. tostring(updated_scripts) .. ", файлы: " .. tostring(updated_files) .. ", библиотеки: " .. tostring(updated_libraries))
    else
        sampAddChatMessage("[Updater] Все скрипты, файлы и библиотеки актуальны", 0x00FF00)
    end
    local start_time = os.clock()
    while next(download_status) and (os.clock() - start_time) * 1000 < 30000 do
        wait(100)
    end
    if next(download_status) then
        logToFile("Таймаут ожидания завершения загрузок")
    end
    logToFile("Завершение downloadUpdates")
    download_complete = true
end

function checkForUpdates()
    logToFile("Начало проверки обновлений")
    is_checking_updates = true
    local max_attempts = 3
    local function tryDownload(url, temp_file, callback)
        local attempt = 1
        while attempt <= max_attempts do
            logToFile("Попытка загрузки " .. url .. " #" .. attempt)
            local download_done = false
            local success, download_error
            downloadFile(url, temp_file, function(result, err)
                success = result
                download_error = err
                download_done = true
            end)
            local timeout = 30000
            local start_time = os.clock()
            while not download_done and (os.clock() - start_time) * 1000 < timeout do
                wait(100)
            end
            if not download_done then
                logToFile("Таймаут загрузки " .. temp_file)
            elseif success then
                local file = io.open(temp_file, "rb")
                if file then
                    local content = file:read("*a"):gsub("^\239\187\191", ""):gsub("[\r\n]+$", "")
                    file:close()
                    if content == "" then
                        logToFile("Пустое содержимое " .. temp_file)
                        return false
                    end
                    local config, _, err = json.decode(content)
                    if not config or err then
                        logToFile("Ошибка парсинга " .. temp_file .. ": " .. tostring(err))
                        return false
                    end
                    callback(config)
                    return true
                else
                    logToFile("Не удалось открыть " .. temp_file)
                    return false
                end
            else
                logToFile("Ошибка загрузки " .. temp_file .. ": " .. tostring(download_error))
            end
            attempt = attempt + 1
            wait(1000)
        end
        return false
    end
    local success = tryDownload(
        string.format("https://raw.githubusercontent.com/%s/%s/%s/update_config.json", GITHUB_USER, GITHUB_REPO, GITHUB_BRANCH),
        TEMP_JSON,
        function(config)
            remote_versions = config
            for _, entry in ipairs(config.scripts or {}) do
                if entry.name and entry.description then
                    local_versions.descriptions[entry.name] = entry.description
                end
                if entry.name and entry.command then
                    local_versions.commands[entry.name] = entry.command
                end
            end
            for _, entry in ipairs(config.files or {}) do
                if entry.name and entry.description then
                    local_versions.descriptions[entry.name] = entry.description
                end
            end
            for _, entry in ipairs(config.libraries or {}) do
                if entry.name and entry.description then
                    local_versions.descriptions[entry.name] = entry.description
                end
            end
            -- Для updater.lua заменяем версию из конфига на script_version
            if config.scripts then
                for _, entry in ipairs(config.scripts) do
                    if entry.name == UPDATER_NAME then
                        entry.version = script_version
                        break
                    end
                end
            end
        end
    )
    if not success then
        logToFile("Не удалось загрузить update_config.json после " .. max_attempts .. " попыток")
        is_checking_updates = false
        return
    end
    success = tryDownload(
        string.format("https://raw.githubusercontent.com/%s/%s/%s/update_development.json", GITHUB_USER, GITHUB_REPO, GITHUB_BRANCH),
        DEV_TEMP_JSON,
        function(config)
            development_versions = config
            for _, entry in ipairs(config.scripts or {}) do
                if entry.name and entry.description then
                    local_versions.descriptions[entry.name] = entry.description
                end
                if entry.name and entry.command then
                    local_versions.commands[entry.name] = entry.command
                end
            end
        end
    )
    if doesFileExist(DEV_TEMP_JSON) then pcall(os.remove, DEV_TEMP_JSON) end
    if not success then
        logToFile("Не удалось загрузить update_development.json после " .. max_attempts .. " попыток")
    end
    downloadUpdates()
    if updater_updated then
        return
    end
    process_scripts("load")
    sampAddChatMessage("[Updater] Скрипты запущены после обновления!", 0x00FF00)
end

function process_scripts(action)
    local function load_or_unload_script(entry, is_dev)
        if not entry.name or not entry.path then
            logToFile("Некорректная структура записи для скрипта: " .. (entry.name or "без имени"))
            return
        end
        local script_handle = script.find(entry.name)
        local success, result = true, nil
        local load_path = entry.path:gsub("/", "\\")
        local full_path = SAVE_PATH .. load_path
        if action == "load" and not script_handle then
            if not enabled_scripts[entry.name] then
                enabled_scripts[entry.name] = imgui.new.bool(false)
                saveJson(ENABLED_JSON, enabled_scripts)
                logToFile("Скрипт " .. entry.name .. " добавлен в enabled_scripts с состоянием false")
            end
            if enabled_scripts[entry.name][0] then
                logToFile("Попытка загрузки " .. (is_dev and "скрипта разработки" or "скрипта") .. ": " .. entry.name .. " по пути " .. load_path)
                if doesFileExist(full_path) then
                    success, result = pcall(script.load, load_path)
                    if success then
                    else
                        logToFile("Ошибка загрузки " .. (is_dev and "скрипта разработки" or "скрипта") .. " " .. entry.name .. ": " .. tostring(result))
                    end
                else
                    logToFile("Файл не найден: " .. full_path)
                end
            else
                logToFile("Скрипт " .. entry.name .. " отключен (чекбокс выключен)")
            end
        elseif action == "unload" and script_handle then
            success, result = pcall(script_handle.unload, script_handle)
            if not success then
                logToFile("Ошибка выгрузки " .. (is_dev and "скрипта разработки" or "скрипта") .. " " .. entry.name .. ": " .. tostring(result))
            end
        end
        if not success then
            logToFile("Критическая ошибка во время " .. action .. " " .. (is_dev and "скрипта разработки" or "скрипта") .. " " .. entry.name .. ": " .. tostring(result))
        end
    end
    if remote_versions and remote_versions.scripts then
        for _, entry in ipairs(remote_versions.scripts) do
            if entry.name ~= UPDATER_NAME then
                load_or_unload_script(entry, false)
            end
        end
    end
    if action == "load" and development_versions and development_versions.scripts and isPlayerAllowed() then
        for _, entry in ipairs(development_versions.scripts) do
            load_or_unload_script(entry, true)
        end
    end
    return true
end

function reload_single_item(name, path, is_script, is_file)
    logToFile("Перезагрузка " .. (is_script and "скрипта" or is_file and "файла" or "библиотеки") .. ": " .. name)
    if is_script and name == UPDATER_NAME then
        return
    end
    local entry, source = nil, is_script and remote_versions.scripts or is_file and remote_versions.files or remote_versions.libraries
    for _, e in ipairs(source or {}) do
        if e.name == name then
            entry = e
            break
        end
    end
    if not entry and is_script and development_versions and development_versions.scripts then
        for _, e in ipairs(development_versions.scripts) do
            if e.name == name then
                entry = e
                break
            end
        end
    end
    if not entry then
        logToFile("Запись для " .. name .. " не найдена")
        sampAddChatMessage("[Updater] Запись для " .. name .. " не найдена", 0xFF0000)
        return
    end
    local file_path = path or (SAVE_PATH .. entry.path:gsub("/", "\\"))
    createDirectoriesForPath(file_path)
    download_status[name] = true
    downloadFile(string.format("https://raw.githubusercontent.com/%s/%s/%s/%s", GITHUB_USER, GITHUB_REPO, GITHUB_BRANCH, entry.path), file_path, function(success, err)
        download_status[name] = nil
        if success then
            if is_file and entry.run_after_download then
                local process_name = name:lower()
                if isProcessRunning(process_name) then killProcess(process_name) end
                local dir_path = file_path:match("^(.*\\)[^\\]+$") or SAVE_PATH
                local success, err = pcall(function()
                    os.execute('cd /d "' .. dir_path .. '" && start /min "" "' .. file_path .. '"')
                end)
                if not success then
                    logToFile("Ошибка запуска файла " .. file_path .. ": " .. tostring(err))
                end
            end
            if is_script then
                local load_path = path or entry.path:gsub("/", "\\")
                if not enabled_scripts[name] then
                    enabled_scripts[name] = imgui.new.bool(false)
                    saveJson(ENABLED_JSON, enabled_scripts)
                    logToFile("Скрипт " .. name .. " добавлен в enabled_scripts с состоянием false при перезагрузке")
                end
                local script_handle = script.find(name)
                if script_handle then
                    local success, result = pcall(script_handle.unload, script_handle)
                    if not success then
                        logToFile("Ошибка выгрузки скрипта " .. name .. ": " .. tostring(result))
                        return
                    end
                end
                if enabled_scripts[name][0] then
                    logToFile("Попытка загрузки скрипта: " .. name .. " по пути " .. load_path)
                    local success, result = pcall(script.load, load_path)
                    if success then
                    else
                        logToFile("Ошибка перезагрузки скрипта " .. name .. ": " .. tostring(result))
                    end
                else
                    sampAddChatMessage("[Updater] Скрипт " .. name .. " отключен", 0xFFFF00)
                end
            else
                local_versions[is_file and "files" or "libraries"][name] = entry.version
                saveJson(LOCAL_JSON, local_versions)
            end
        else
            logToFile("Ошибка перезагрузки " .. (is_script and "скрипта" or is_file and "файла" or "библиотеки") .. " " .. name .. ": " .. tostring(err))
            sampAddChatMessage("[Updater] Ошибка перезагрузки " .. (is_script and "скрипта" or is_file and "файла" or "библиотеки") .. " " .. name, 0xFF0000)
            if doesFileExist(file_path) then pcall(os.remove, file_path) end
        end
    end)
end

function execute_script_command(script_name)
    logToFile("Выполнение команды для скрипта: " .. script_name)
    local command = (local_versions.commands[script_name] or dev_versions.commands[script_name])
    if not command then
        sampAddChatMessage("[Updater] Команда для " .. script_name .. " не указана", 0xFFFF00)
        return
    end
    local script_handle = script.find(script_name)
    if not script_handle and enabled_scripts[script_name] and enabled_scripts[script_name][0] then
        local load_path = nil
        for _, entry in ipairs(development_versions and development_versions.scripts or {}) do
            if entry.name == script_name then
                load_path = entry.path:gsub("/", "\\")
                break
            end
        end
        if not load_path then
            for _, entry in ipairs(remote_versions.scripts or {}) do
                if entry.name == script_name then
                    load_path = entry.path:gsub("/", "\\")
                    break
                end
            end
        end
        if load_path and doesFileExist(SAVE_PATH .. load_path) then
            logToFile("Попытка загрузки скрипта: " .. script_name .. " по пути " .. load_path)
            local success, result = pcall(script.load, load_path)
            if success then
                wait(1000)
                script_handle = script.find(script_name)
            else
                logToFile("Ошибка загрузки скрипта " .. script_name .. ": " .. tostring(result))
                return
            end
        else
            logToFile("Файл скрипта не найден: " .. (load_path or "не указан путь"))
            sampAddChatMessage("[Updater] Файл скрипта " .. script_name .. " не найден", 0xFF0000)
            return
        end
    end
    if script_handle then
        local command_name = command:match("^/(%S+)") or command
        local command_func = script_handle[command_name]
        if command_func and type(command_func) == "function" then
            local args = command:match("^/%S+ (.+)$") or ""
            local success, result = pcall(command_func, args)
            if success then
            else
                logToFile("Ошибка выполнения команды " .. script_name .. ": " .. tostring(result))
                sampProcessChatInput(command)
            end
        else
            sampProcessChatInput(command)
        end
    end
end

imgui.OnInitialize(function()
    imgui.GetIO().IniFilename = nil
    logToFile("ImGui инициализировано")
end)

function renderTable(title, items, versions, is_script, category)
    local columns = is_script and 7 or 4
    -- Закреплённые заголовки таблицы
    imgui.BeginChild("TableHeaders_" .. category, imgui.ImVec2(0, 30), false, imgui.WindowFlags.NoScrollbar)
    imgui.Columns(columns, category .. "_table", false)
    imgui.SetColumnWidth(0, 150)
    imgui.SetColumnWidth(1, is_script and 50 or 80)
    if is_script then
        imgui.SetColumnWidth(2, 90)
        imgui.SetColumnWidth(3, 100)
        imgui.SetColumnWidth(4, 50)
        imgui.SetColumnWidth(5, 88)
        imgui.SetColumnWidth(6, 400)
        imgui.Text(u8"Имя скрипта") imgui.NextColumn()
        imgui.Text(u8"Версия") imgui.NextColumn()
        imgui.Text(u8"Состояние") imgui.NextColumn()
        imgui.Text(u8"Команда") imgui.NextColumn()
        imgui.Text(u8"Статус") imgui.NextColumn()
        imgui.Text(u8"Перезагрузка") imgui.NextColumn()
        imgui.Text(u8"Описание") imgui.NextColumn()
    else
        imgui.SetColumnWidth(2, 120)
        imgui.SetColumnWidth(3, 200)
        imgui.Text(u8"Имя") imgui.NextColumn()
        imgui.Text(u8"Версия") imgui.NextColumn()
        imgui.Text(u8"Перезагрузка") imgui.NextColumn()
        imgui.Text(u8"Описание") imgui.NextColumn()
    end
    imgui.Separator()
    imgui.EndChild()
    -- Прокручиваемое содержимое таблицы
    imgui.BeginChild("TableContent_" .. category, imgui.ImVec2(0, 0), false)
    imgui.Columns(columns, category .. "_table_content", false)
    imgui.SetColumnWidth(0, 150)
    imgui.SetColumnWidth(1, is_script and 50 or 80)
    if is_script then
        imgui.SetColumnWidth(2, 90)
        imgui.SetColumnWidth(3, 100)
        imgui.SetColumnWidth(4, 50)
        imgui.SetColumnWidth(5, 88)
        imgui.SetColumnWidth(6, 400)
    else
        imgui.SetColumnWidth(2, 120)
        imgui.SetColumnWidth(3, 200)
    end
    if items then
        for _, entry in ipairs(items) do
            local name = entry.name
            -- Пропускаем updater.lua для отображения в списке скриптов
            if is_script and name == UPDATER_NAME then
                goto continue
            end
            local version = versions[name] or entry.version or "N/A"
            if is_script then
                local is_dev = false
                for _, dev_entry in ipairs(development_versions and development_versions.scripts or {}) do
                    if dev_entry.name == name then is_dev = true break end
                end
                if category == "dev_scripts" and not is_dev or category ~= "dev_scripts" and is_dev then
                    goto continue
                end
            end
            local description = to_utf8(local_versions.descriptions[name] or dev_versions.descriptions[name] or u8"Нет описания")
            local command = is_script and (local_versions.commands[name] or dev_versions.commands[name] or u8"No command") or nil
            local is_loaded = is_script and script.find(name) ~= nil
            if is_script then
                if imgui.Selectable(u8(name), false) then
                    local success, err = pcall(execute_script_command, name)
                    if not success then
                    end
                end
            else
                imgui.Text(u8(name))
            end
            imgui.NextColumn()
            imgui.Text(u8("v" .. tostring(version))) imgui.NextColumn()
            if is_script then
                if is_loaded then
                    imgui.PushStyleColor(imgui.Col.Text, imgui.ImVec4(0.0, 1.0, 0.0, 1.0))
                    imgui.Text(u8"Загружен")
                    imgui.PopStyleColor()
                else
                    imgui.PushStyleColor(imgui.Col.Text, imgui.ImVec4(1.0, 0.0, 0.0, 1.0))
                    imgui.Text(u8"Не загружен")
                    imgui.PopStyleColor()
                end
                imgui.NextColumn()
                imgui.Text(u8(command)) imgui.NextColumn()
                if imgui.Checkbox(u8("##enabled_" .. name), enabled_scripts[name] or imgui.new.bool(false)) then
                    enabled_scripts[name] = enabled_scripts[name] or imgui.new.bool(false)
                    saveJson(ENABLED_JSON, enabled_scripts)
                    if not enabled_scripts[name][0] and script.find(name) then
                        local script_handle = script.find(name)
                        local success, result = pcall(script_handle.unload, script_handle)
                        if success then
                            sampAddChatMessage("[Updater] Скрипт " .. name .. " выгружен", 0x00FF00)
                        else
                            logToFile("Ошибка выгрузки скрипта " .. name .. ": " .. tostring(result))
                        end
                    end
                end
                imgui.NextColumn()
            end
            if download_status[name] then
                local pulse = math.sin(imgui.GetTime() * 4.0) * 0.1 + 0.9
                imgui.PushStyleColor(imgui.Col.Button, imgui.ImVec4(0.5 * pulse, 0.5 * pulse, 0.5 * pulse, 0.5))
                imgui.PushStyleColor(imgui.Col.ButtonHovered, imgui.ImVec4(0.5 * pulse, 0.5 * pulse, 0.5 * pulse, 0.5))
                imgui.PushStyleColor(imgui.Col.ButtonActive, imgui.ImVec4(0.5 * pulse, 0.5 * pulse, 0.5 * pulse, 0.5))
                imgui.Button(u8("Reload##reload_" .. name))
                imgui.PopStyleColor(3)
            else
                if imgui.Button(u8("Reload##reload_" .. name)) then
                    local success, err = pcall(reload_single_item, name, nil, is_script, category == "files")
                    if not success then
                        logToFile("Ошибка перезагрузки " .. (is_script and "скрипта" or category == "files" and "файла" or "библиотеки") .. " " .. name .. ": " .. tostring(err))
                    end
                end
            end
            imgui.NextColumn()
            imgui.TextWrapped(u8(description))
            imgui.NextColumn()
            imgui.Separator()
            ::continue::
        end
    else
        imgui.Text(u8("Нет данных о " .. (category == "scripts" and "скриптах" or category == "files" and "файлах" or category == "libraries" and "библиотеках" or "скриптах разработки")))
    end
    imgui.Columns(1)
    imgui.EndChild()
end

imgui.OnFrame(
    function() return showMenu[0] end,
    function()
        local success, err = pcall(function()
            -- Применение стиля из Pogoda.lua
            local style = imgui.GetStyle()
            local colors = style.Colors
            local clr = imgui.Col
            local ImVec4 = imgui.ImVec4
            style.WindowRounding = 15.0
            style.WindowTitleAlign = imgui.ImVec2(0.5, 0.5)
            style.FrameRounding = 10.0
            style.ScrollbarRounding = 10.0
            style.GrabRounding = 10.0
            style.ItemSpacing = imgui.ImVec2(8.0, 6.0)
            style.ScrollbarSize = 12.0
            style.GrabMinSize = 10.0
            style.ButtonTextAlign = imgui.ImVec2(0.5, 0.5)
            style.AntiAliasedLines = true
            style.AntiAliasedFill = true
            style.WindowBorderSize = 0.0
            style.FrameBorderSize = 0.5
            colors[clr.Text] = ImVec4(0.95, 0.95, 0.95, 1.00)
            colors[clr.WindowBg] = ImVec4(0.10, 0.10, 0.12, 0.85)
            colors[clr.FrameBg] = ImVec4(0.15, 0.15, 0.20, 0.70)
            colors[clr.FrameBgHovered] = ImVec4(0.25, 0.50, 0.75, 0.80)
            colors[clr.FrameBgActive] = ImVec4(0.30, 0.60, 0.85, 0.90)
            colors[clr.Button] = ImVec4(0.20, 0.40, 0.70, 0.70)
            colors[clr.ButtonHovered] = ImVec4(0.25, 0.50, 0.80, 0.90)
            colors[clr.ButtonActive] = ImVec4(0.30, 0.60, 0.90, 1.00)
            colors[clr.CheckMark] = ImVec4(0.30, 0.60, 0.90, 1.00)
            colors[clr.SliderGrab] = ImVec4(0.25, 0.50, 0.80, 1.00)
            colors[clr.SliderGrabActive] = ImVec4(0.30, 0.60, 0.90, 1.00)
            colors[clr.TitleBg] = ImVec4(0.10, 0.10, 0.12, 0.85)
            colors[clr.TitleBgActive] = ImVec4(0.10, 0.10, 0.12, 0.85)
            colors[clr.TitleBgCollapsed] = ImVec4(0.10, 0.10, 0.12, 0.85)
            logToFile("Стиль ImGui применён")
            imgui.ShowCursor = true
            imgui.SetNextWindowSize(imgui.ImVec2(700, 500), imgui.Cond.Always)
            local screen_x, screen_y = getScreenResolution()
            imgui.SetNextWindowPos(imgui.ImVec2(screen_x / 2, screen_y / 2), imgui.Cond.Always, imgui.ImVec2(0.5, 0.5))
            imgui.Begin(u8"Dunaevskiy Lua Scripts##main_window", showMenu, imgui.WindowFlags.NoTitleBar + imgui.WindowFlags.NoResize + imgui.WindowFlags.NoScrollbar)
            -- Кастомный заголовок с отцентрированным текстом и кнопкой закрытия
            imgui.BeginChild("CustomTitle", imgui.ImVec2(0, 30), false, imgui.WindowFlags.NoScrollbar)
            local text = u8"Dunaevskiy Lua Scripts Updater"
            local text_width = imgui.CalcTextSize(text).x
            local window_width = imgui.GetWindowWidth()
            imgui.SetCursorPosX((window_width - text_width - 40) / 2) -- Центрируем текст, учитывая ширину кнопки закрытия (40)
            imgui.Text(text)
            imgui.SameLine()
            imgui.SetCursorPosX(window_width - 40) -- Позиционируем крестик справа
            if imgui.Button(u8"Х", imgui.ImVec2(30, 20)) then
                showMenu[0] = false -- Закрываем окно
            end
            imgui.EndChild()
            -- Закреплённые кнопки без рамки и полосы прокрутки
            imgui.BeginChild("Tabs", imgui.ImVec2(0, 40), false, imgui.WindowFlags.NoScrollbar)
            local button_count = isPlayerAllowed() and 4 or 3
            local button_width = (imgui.GetWindowContentRegionWidth() - (button_count - 1) * 5) / button_count
            local active_button_color = ImVec4(0.30, 0.60, 0.90, 1.00)
            local inactive_button_color = ImVec4(0.20, 0.40, 0.70, 0.70)
            -- Кнопка "Скрипты"
            imgui.PushStyleColor(imgui.Col.Button, active_tab[0] == 0 and active_button_color or inactive_button_color)
            if imgui.Button(u8"Скрипты##scripts_tab", imgui.ImVec2(button_width, 30)) then active_tab[0] = 0 end
            imgui.PopStyleColor()
            imgui.SameLine(0, 5)
            -- Кнопка "Файлы"
            imgui.PushStyleColor(imgui.Col.Button, active_tab[0] == 1 and active_button_color or inactive_button_color)
            if imgui.Button(u8"Файлы##files_tab", imgui.ImVec2(button_width, 30)) then active_tab[0] = 1 end
            imgui.PopStyleColor()
            imgui.SameLine(0, 5)
            -- Кнопка "Библиотеки"
            imgui.PushStyleColor(imgui.Col.Button, active_tab[0] == 2 and active_button_color or inactive_button_color)
            if imgui.Button(u8"Библиотеки##libraries_tab", imgui.ImVec2(button_width, 30)) then active_tab[0] = 2 end
            imgui.PopStyleColor()
            -- Кнопка "Разработка" (если разрешено)
            if isPlayerAllowed() then
                imgui.SameLine(0, 5)
                imgui.PushStyleColor(imgui.Col.Button, active_tab[0] == 3 and active_button_color or inactive_button_color)
                if imgui.Button(u8"Разработка##dev_tab", imgui.ImVec2(button_width, 30)) then active_tab[0] = 3 end
                imgui.PopStyleColor()
            end
            imgui.EndChild()
            -- Прокручиваемый контент
            imgui.BeginChild("Content", imgui.ImVec2(0, -40))
            if active_tab[0] == 0 then
                renderTable("Скрипты", remote_versions and remote_versions.scripts, local_versions.versions, true, "scripts")
            elseif active_tab[0] == 1 then
                renderTable("Файлы", remote_versions and remote_versions.files, local_versions.files, false, "files")
            elseif active_tab[0] == 2 then
                renderTable("Библиотеки", remote_versions and remote_versions.libraries, local_versions.libraries, false, "libraries")
            elseif active_tab[0] == 3 and isPlayerAllowed() then
                renderTable("Разработка", development_versions and development_versions.scripts, local_versions.dev_versions or {}, true, "dev_scripts")
            end
            imgui.EndChild()
            imgui.Separator()
            if is_checking_updates then
                local pulse = math.sin(imgui.GetTime() * 4.0) * 0.1 + 0.9
                imgui.PushStyleColor(imgui.Col.Button, imgui.ImVec4(0.0, 0.8 * pulse, 0.0, 1.0))
                imgui.PushStyleColor(imgui.Col.ButtonHovered, imgui.ImVec4(0.0, 1.0 * pulse, 0.0, 1.0))
                imgui.PushStyleColor(imgui.Col.ButtonActive, imgui.ImVec4(0.0, 0.6 * pulse, 0.0, 1.0))
                imgui.Button(u8"Проверка...##check_updates", imgui.ImVec2(-1, 30))
                imgui.PopStyleColor(3)
            else
                imgui.PushStyleColor(imgui.Col.Button, imgui.ImVec4(0.0, 0.8, 0.0, 1.0))
                imgui.PushStyleColor(imgui.Col.ButtonHovered, imgui.ImVec4(0.0, 1.0, 0.0, 1.0))
                imgui.PushStyleColor(imgui.Col.ButtonActive, imgui.ImVec4(0.0, 0.6, 0.0, 1.0))
                if imgui.Button(u8"Проверить обновления##check_updates", imgui.ImVec2(-1, 30)) then
                    is_checking_updates = true
                    lua_thread.create(checkForUpdates)
                end
                imgui.PopStyleColor(3)
            end
            imgui.End()
        end)
        if not success then
            logToFile("Ошибка ImGui: " .. tostring(err))
            sampAddChatMessage("[Updater] Ошибка рендеринга ImGui", 0xFF0000)
        end
    end
)

addEventHandler("onScriptTerminate", function(scr)
    if scr == thisScript() then
        process_scripts("unload")
        is_script_running = false
    end
end)

function main()
    if not isSampLoaded() or not isSampfuncsLoaded() then
        logToFile("SA:MP или sampfuncs не загружены")
        sampAddChatMessage("[Updater] SA:MP или sampfuncs не загружены", 0xFF0000)
        return
    end
    local game_dir = getGameDirectory()
    if not game_dir then
        logToFile("Ошибка: getGameDirectory вернул nil")
        return
    end
    SAVE_PATH = game_dir .. "\\moonloader\\"
    scripts_dir_rel = "LuaDunaevskiy"
    scripts_dir_abs = SAVE_PATH .. scripts_dir_rel .. "\\"
    LOCAL_JSON = SAVE_PATH .. "LuaDunaevskiy\\versions.json"
    ENABLED_JSON = SAVE_PATH .. "LuaDunaevskiy\\enabled.json"
    TEMP_JSON = SAVE_PATH .. "LuaDunaevskiy\\temp_config.json"
    DEV_TEMP_JSON = SAVE_PATH .. "LuaDunaevskiy\\temp_development.json"
    UPDATER_NAME = "updater.lua"
    local_versions = loadJson(LOCAL_JSON, { versions = {}, files = {}, libraries = {}, dev_versions = {}, descriptions = {}, commands = {} })
    dev_versions = { versions = local_versions.dev_versions or {}, descriptions = {}, commands = {} }
    enabled_scripts = loadJson(ENABLED_JSON, {})
    if not enabled_scripts then
        enabled_scripts = {}
        logToFile("enabled_scripts установлено в пустую таблицу в main")
    end
    clearLogFile()
    while not isSampAvailable() do wait(100) end
    sampRegisterChatCommand("DunLua", function()
        showMenu[0] = not showMenu[0]
    end)
    sampAddChatMessage("[Updater] Проверка обновлений...", 0x00FF00)
    download_complete = false
    lua_thread.create(checkForUpdates)
    while true do
        wait(0)
        imgui.Process = showMenu[0]
    end
end